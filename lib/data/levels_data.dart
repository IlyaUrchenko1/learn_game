import 'package:learn_game/models/level_model.dart';
import 'package:learn_game/models/test_model.dart';

final List<Level> allLevels = [
  Level(
    id: 1,
    title: "Уровень 1: Основы",
    guideText: """
## Добро пожаловать в мир Flutter!

Flutter — это набор инструментов для разработки пользовательского интерфейса (UI) от Google, который позволяет создавать быстрые, красивые и нативно компилируемые приложения для мобильных, веб- и десктопных платформ из единой кодовой базы.

### Ключевые особенности:
- **Быстрая разработка**: Благодаря функции Hot Reload, вы можете мгновенно видеть изменения в коде, что значительно ускоряет процесс разработки.
- **Выразительный UI**: Flutter позволяет создавать сложные и красивые интерфейсы с помощью мощной системы виджетов.
- **Нативная производительность**: Код компилируется в нативный код для каждой платформы, обеспечивая высокую производительность.

### Язык Dart
Flutter использует язык программирования Dart, который также разработан Google. Dart оптимизирован для разработки UI и обеспечивает быструю и эффективную работу приложений.

На этом уровне вы познакомитесь с базовыми концепциями Flutter и Dart. Удачи!
""",
    test: [
      Question(
        question: "Что такое Flutter?",
        answers: ["Фреймворк", "Язык", "База данных", "IDE"],
        correctAnswerIndex: 0,
      ),
      Question(
        question: "На каком языке работает Flutter?",
        answers: ["Java", "Swift", "Dart", "Kotlin"],
        correctAnswerIndex: 2,
      ),
    ],
  ),
  Level(
    id: 2,
    title: "Уровень 2: Виджеты",
    guideText: """
## Все во Flutter — это виджет!

Виджеты — это основные строительные блоки в Flutter. Каждый элемент на экране, от кнопки до отступа, является виджетом.

### Основные категории виджетов:
- **StatelessWidget**: Виджеты без состояния. Их свойства (например, цвет или текст) не могут изменяться после создания. Примеры: `Text`, `Icon`, `Row`, `Column`.
- **StatefulWidget**: Виджеты с состоянием. Они могут изменять свой внутренний вид в ответ на действия пользователя или другие события. Примеры: `Checkbox`, `TextField`, `Slider`.

### Композиция виджетов
Вы создаете интерфейс, комбинируя простые виджеты для создания более сложных. Например, вы можете поместить виджет `Text` и `Icon` в `Row`, чтобы создать строку с иконкой и текстом.

В этом уроке вы научитесь использовать основные виджеты для построения пользовательских интерфейсов.
""",
    test: [
      Question(
        question: "Какой виджет используется для создания строки?",
        answers: ["Column", "Row", "Text", "Container"],
        correctAnswerIndex: 1,
      ),
      Question(
        question: "Какой виджет используется для создания кнопки?",
        answers: ["ElevatedButton", "Image", "Icon", "ListView"],
        correctAnswerIndex: 0,
      ),
    ],
  ),
  Level(
    id: 3,
    title: "Уровень 3: Управление состоянием",
    guideText: """
## Что такое состояние?

Состояние (state) — это любая информация, которая может изменяться во время работы приложения. Например, значение счетчика, содержимое корзины покупок или статус аутентификации пользователя.

### Подходы к управлению состоянием:
- **setState()**: Базовый механизм в `StatefulWidget` для локального управления состоянием.
- **Provider**: Популярный пакет, который позволяет "предоставлять" состояние виджетам-потомкам в дереве виджетов. Это упрощает доступ к данным и их обновление.
- **BLoC (Business Logic Component)**: Паттерн, который разделяет бизнес-логику от UI, делая код более тестируемым и масштабируемым.

Правильное управление состоянием — ключ к созданию стабильных и предсказуемых приложений. На этом уровне мы рассмотрим `Provider` как один из самых распространенных подходов.
""",
    test: [
      Question(
        question: "Какой пакет часто используется для управления состоянием?",
        answers: ["http", "shared_preferences", "provider", "url_launcher"],
        correctAnswerIndex: 2,
      ),
    ],
  ),
  Level(
    id: 4,
    title: "Уровень 4: Dart OOP",
    guideText: """
## Объектно-ориентированное программирование (ООП) в Dart

Dart — это объектно-ориентированный язык. Все в Dart является объектом, включая числа, функции и `null`.

### Основные концепции ООП:
- **Классы и объекты**: Класс — это "чертеж" для создания объектов. Объект — это экземпляр класса.
- **Наследование**: Механизм, позволяющий одному классу (`дочернему`) наследовать свойства и методы другого (`родительского`). Используется ключевое слово `extends`.
- **Инкапсуляция**: Сокрытие внутренней реализации объекта и предоставление только публичного интерфейса для взаимодействия с ним.
- **Полиморфизм**: Способность объектов разных классов отвечать на один и тот же вызов метода по-разному.

Понимание ООП необходимо для написания чистого, структурированного и многократно используемого кода на Dart.
""",
    test: [
      Question(
        question: "Что такое класс в Dart?",
        answers: [
          "План для создания объектов",
          "Функция",
          "Переменная",
          "Библиотека",
        ],
        correctAnswerIndex: 0,
      ),
      Question(
        question: "Как объявить конструктор в Dart?",
        answers: ["ИмяКласса()", "constructor()", "new ИмяКласса()", "init()"],
        correctAnswerIndex: 0,
      ),
      Question(
        question: "Что такое наследование?",
        answers: [
          "Механизм, позволяющий одному классу наследовать свойства и методы другого",
          "Способ создания копии объекта",
          "Паттерн проектирования",
          "Тип данных",
        ],
        correctAnswerIndex: 0,
      ),
    ],
  ),
  Level(
    id: 5,
    title: "Уровень 5: Асинхронный Dart",
    guideText: """
## Работа с асинхронными операциями

Многие операции, такие как сетевые запросы или чтение из базы данных, занимают время. Чтобы не блокировать пользовательский интерфейс, Dart использует асинхронное программирование.

### Future
`Future` — это объект, представляющий результат асинхронной операции, который будет доступен в будущем. Он может завершиться либо с результатом (успех), либо с ошибкой.

### async / await
- **async**: Ключевое слово, которое помечает функцию как асинхронную. Такая функция всегда возвращает `Future`.
- **await**: Ключевое слово, которое "приостанавливает" выполнение асинхронной функции до тех пор, пока `Future` не завершится. Это позволяет писать асинхронный код, который выглядит как синхронный.

Асинхронное программирование — неотъемлемая часть современной разработки, и в Dart оно реализовано очень удобно.
""",
    test: [
      Question(
        question: "Что возвращает асинхронная функция в Dart?",
        answers: ["int", "String", "Future", "void"],
        correctAnswerIndex: 2,
      ),
      Question(
        question: "Для чего используется ключевое слово 'await'?",
        answers: [
          "Для создания новой функции",
          "Для ожидания завершения Future",
          "Для объявления переменной",
          "Для вывода данных",
        ],
        correctAnswerIndex: 1,
      ),
    ],
  ),
  Level(
    id: 6,
    title: "Уровень 6: Flutter Navigation",
    guideText: """
## Навигация между экранами

Большинство приложений состоят из нескольких экранов. Flutter предоставляет мощную систему для навигации между ними.

### Navigator
`Navigator` — это виджет, который управляет стеком дочерних виджетов (экранов). Когда вы переходите на новый экран, он помещается на вершину стека. Когда вы нажимаете кнопку "назад", он удаляется из стека.

### Маршруты (Routes)
Маршрут — это абстракция для экрана или страницы. Существует два основных способа управления маршрутами:
1. **Анонимные маршруты**: Создаются "на лету" с помощью `MaterialPageRoute`.
2. **Именованные маршруты**: Определяются заранее в `MaterialApp` и вызываются по имени. Это предпочтительный способ для более крупных приложений.

На этом уровне вы научитесь создавать многоэкранные приложения и передавать данные между экранами.
""",
    test: [
      Question(
        question: "Какой виджет используется для управления стеком навигации?",
        answers: ["Router", "Navigator", "Stack", "PageManager"],
        correctAnswerIndex: 1,
      ),
      Question(
        question: "Как передать данные на новый экран?",
        answers: [
          "Через глобальные переменные",
          "Через конструктор нового экрана",
          "Через файл",
          "Никак",
        ],
        correctAnswerIndex: 1,
      ),
    ],
  ),
];
